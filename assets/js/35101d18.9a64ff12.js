"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4460],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=s(n),m=r,k=c["".concat(p,".").concat(m)]||c[m]||d[m]||l;return n?a.createElement(k,o(o({ref:t},u),{},{components:n})):a.createElement(k,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=c;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48921:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return d}});var a=n(87462),r=n(63366),l=(n(67294),n(3905)),o=["components"],i={sidebar_position:6,title:"Operators"},p=void 0,s={unversionedId:"c8ql/operators",id:"c8ql/operators",title:"Operators",description:"Overview",source:"@site/docs/c8ql/operators.md",sourceDirName:"c8ql",slug:"/c8ql/operators",permalink:"/docs/c8ql/operators",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/master/docs/c8ql/operators.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Operators"},sidebar:"tutorialSidebar",previous:{title:"Fundamentals",permalink:"/docs/c8ql/fundamentals"},next:{title:"Data Queries",permalink:"/docs/c8ql/data-queries"}},u={},d=[{value:"Overview",id:"overview",level:2},{value:"Comparison operators",id:"comparison-operators",level:2},{value:"Array comparison operators",id:"array-comparison-operators",level:2},{value:"Logical operators",id:"logical-operators",level:2},{value:"Arithmetic operators",id:"arithmetic-operators",level:2},{value:"Ternary operator",id:"ternary-operator",level:2},{value:"Range operator",id:"range-operator",level:2},{value:"Array operators",id:"array-operators",level:2},{value:"Operator precedence",id:"operator-precedence",level:2}],c={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"overview"},"Overview"),(0,l.kt)("p",null,"C8QL supports a number of operators that can be used in expressions.  There are comparison, logical, arithmetic, and the ternary operator."),(0,l.kt)("h2",{id:"comparison-operators"},"Comparison operators"),(0,l.kt)("p",null,"Comparison (or relational) operators compare two operands. They can be used with any input data types, and will return a boolean result value."),(0,l.kt)("p",null,"The following comparison operators are supported:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"==")," equality"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"!=")," inequality"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"<"),"  less than "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"<=")," less or equal"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},">")," greater than"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},">=")," greater or equal"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"IN")," test if a value is contained in an array"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"NOT IN")," test if a value is not contained in an array"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LIKE")," tests if a string value matches a pattern"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"=~")," tests if a string value matches a regular expression"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"!~")," tests if a string value does not match a regular expression")),(0,l.kt)("p",null,"Each of the comparison operators returns a boolean value if the comparison can be evaluated and returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," if the comparison evaluates to true, and ",(0,l.kt)("inlineCode",{parentName:"p"},"false")," otherwise. "),(0,l.kt)("p",null,"The comparison operators accept any data types for the first and second operands. However, ",(0,l.kt)("inlineCode",{parentName:"p"},"IN")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"NOT IN")," will only return a meaningful result if their right-hand operand is a string, and ",(0,l.kt)("inlineCode",{parentName:"p"},"LIKE")," will only execute if both operands are string values. The comparison operators will not perform any implicit type casts if the compared operands have different or non-sensible types."),(0,l.kt)("p",null,"Some examples for comparison operations in C8QL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'0 == null                 // false\n1 > 0                     // true\ntrue != null              // true\n45 <= "yikes!"            // true\n65 != "65"                // true\n65 == 65                  // true\n1.23 > 1.32               // false\n1.5 IN [ 2, 3, 1.5 ]      // true\n"foo" IN null             // false\n42 NOT IN [ 17, 40, 50 ]  // true\n"abc" == "abc"            // true\n"abc" == "ABC"            // false\n"foo" LIKE "f%"           // true\n"foo" =~ "^f[o].$"        // true\n"foo" !~ "[a-z]+bar$"     // true\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"LIKE")," operator checks whether its left operand matches the pattern specified in its right operand. The pattern can consist of regular characters and wildcards. The supported wildcards are ",(0,l.kt)("inlineCode",{parentName:"p"},"_")," to match a single arbitrary character, and ",(0,l.kt)("inlineCode",{parentName:"p"},"%")," to match any number of arbitrary characters. "),(0,l.kt)("p",null,"Literal ",(0,l.kt)("inlineCode",{parentName:"p"},"%")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"_")," need to be escaped with a backslash. Backslashes need to be escaped themselves, which effectively means that two reverse solidus characters need to preceed a literal percent sign or underscore. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'"abc" LIKE "a%"              // true\n"abc" LIKE "_bc"             // true\n"a_b_foo" LIKE "a\\\\_b\\\\_foo" // true\n')),(0,l.kt)("p",null,"The pattern matching performed by the ",(0,l.kt)("inlineCode",{parentName:"p"},"LIKE")," operator is case-sensitive."),(0,l.kt)("p",null,"The regular expression operators ",(0,l.kt)("inlineCode",{parentName:"p"},"=~")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"!~")," expect their left-hand operands to be strings, and their right-hand operands to be strings containing valid regular expressions as specified in the documentation for the C8QL function ",(0,l.kt)("a",{parentName:"p",href:"/docs/c8ql/functions/string"},"REGEX_TEST()"),"."),(0,l.kt)("h2",{id:"array-comparison-operators"},"Array comparison operators"),(0,l.kt)("p",null,"The comparison operators also exist as ",(0,l.kt)("inlineCode",{parentName:"p"},"array variant"),". In the array variant, the operator is prefixed with one of the keywords ",(0,l.kt)("inlineCode",{parentName:"p"},"ALL"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ANY")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"NONE"),". Using one of these keywords changes the operator behavior to execute the comparison operation for all, any, or none of its left hand argument values. It is therefore expected that the left hand argument of an array operator is an array."),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'[ 1, 2, 3 ] ALL IN [ 2, 3, 4 ]   // false\n[ 1, 2, 3 ] ALL IN [ 1, 2, 3 ]   // true\n[ 1, 2, 3 ] NONE IN [ 3 ]        // false\n[ 1, 2, 3 ] NONE IN [ 23, 42 ]   // true\n[ 1, 2, 3 ] ANY IN [ 4, 5, 6 ]   // false\n[ 1, 2, 3 ] ANY IN [ 1, 42 ]     // true\n[ 1, 2, 3 ] ANY == 2             // true\n[ 1, 2, 3 ] ANY == 4             // false\n[ 1, 2, 3 ] ANY > 0              // true\n[ 1, 2, 3 ] ANY <= 1             // true\n[ 1, 2, 3 ] NONE < 99            // false\n[ 1, 2, 3 ] NONE > 10            // true\n[ 1, 2, 3 ] ALL > 2              // false\n[ 1, 2, 3 ] ALL > 0              // true\n[ 1, 2, 3 ] ALL >= 3             // false\n["foo", "bar"] ALL != "moo"      // true\n["foo", "bar"] NONE == "bar"     // false\n["foo", "bar"] ANY == "foo"      // true\n')),(0,l.kt)("p",null,"Note that these operators are not optimized yet. Indexes will not be utilized."),(0,l.kt)("h2",{id:"logical-operators"},"Logical operators"),(0,l.kt)("p",null,"The following logical operators are supported in C8QL:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"&&")," logical and operator"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"||")," logical or operator"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"!")," logical not/negation operator")),(0,l.kt)("p",null,"C8QL also supports the following alternative forms for the logical operators:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"AND")," logical and operator"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"OR")," logical or operator"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"NOT")," logical not/negation operator")),(0,l.kt)("p",null,"The alternative forms are aliases and functionally equivalent to the regular operators."),(0,l.kt)("p",null,"The two-operand logical operators in C8QL will be executed with short-circuit evaluation (except if one of the operands is or includes a subquery. In this case the subquery will be pulled out an evaluated before the logical operator)."),(0,l.kt)("p",null,"The result of the logical operators in C8QL is defined as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"lhs && rhs")," will return ",(0,l.kt)("inlineCode",{parentName:"li"},"lhs")," if it is ",(0,l.kt)("inlineCode",{parentName:"li"},"false")," or would be ",(0,l.kt)("inlineCode",{parentName:"li"},"false")," when converted into a boolean. If ",(0,l.kt)("inlineCode",{parentName:"li"},"lhs")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," or would be ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," when converted to a boolean, ",(0,l.kt)("inlineCode",{parentName:"li"},"rhs")," will be returned."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"lhs || rhs")," will return ",(0,l.kt)("inlineCode",{parentName:"li"},"lhs")," if it is ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," or would be ",(0,l.kt)("inlineCode",{parentName:"li"},"true")," when converted into a boolean. If ",(0,l.kt)("inlineCode",{parentName:"li"},"lhs")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"false")," or would be ",(0,l.kt)("inlineCode",{parentName:"li"},"false")," when converted to a boolean, ",(0,l.kt)("inlineCode",{parentName:"li"},"rhs")," will be returned."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"! value")," will return the negated value of ",(0,l.kt)("inlineCode",{parentName:"li"},"value")," converted into a boolean")),(0,l.kt)("p",null,"Some examples for logical operations in C8QL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'u.age > 15 && u.address.city != ""\ntrue || false\nNOT u.isInvalid\n1 || ! 0\n')),(0,l.kt)("p",null,"Passing non-boolean values to a logical operator is allowed. Any non-boolean operands will be casted to boolean implicitly by the operator, without making the query abort."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"conversion to a boolean value")," works as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"null")," will be converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"false")),(0,l.kt)("li",{parentName:"ul"},"boolean values remain unchanged"),(0,l.kt)("li",{parentName:"ul"},"all numbers unequal to zero are ",(0,l.kt)("inlineCode",{parentName:"li"},"true"),", zero is ",(0,l.kt)("inlineCode",{parentName:"li"},"false")),(0,l.kt)("li",{parentName:"ul"},"an empty string is ",(0,l.kt)("inlineCode",{parentName:"li"},"false"),", all other strings are ",(0,l.kt)("inlineCode",{parentName:"li"},"true")),(0,l.kt)("li",{parentName:"ul"},"arrays (",(0,l.kt)("inlineCode",{parentName:"li"},"[ ]"),") and objects / documents (",(0,l.kt)("inlineCode",{parentName:"li"},"{ }"),") are ",(0,l.kt)("inlineCode",{parentName:"li"},"true"),", regardless of their contents")),(0,l.kt)("p",null,"The result of ",(0,l.kt)("inlineCode",{parentName:"p"},"logical and")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"logical or")," operations can now have any data type and is not necessarily a boolean value."),(0,l.kt)("p",null,"For example, the following logical operations will return boolean values:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"25 > 1 && 42 != 7                          // true\n22 IN [ 23, 42 ] || 23 NOT IN [ 22, 7 ]    // true\n25 != 25                                   // false\n")),(0,l.kt)("p",null,"whereas the following logical operations will not return boolean values:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'1 || 7                                     // 1\nnull || "foo"                              // "foo"\nnull && true                               // null\ntrue && 23                                 // 23\n')),(0,l.kt)("h2",{id:"arithmetic-operators"},"Arithmetic operators"),(0,l.kt)("p",null,"Arithmetic operators perform an arithmetic operation on two numeric operands. The result of an arithmetic operation is again a numeric value."),(0,l.kt)("p",null,"C8QL supports the following arithmetic operators:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"+")," addition"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-")," subtraction"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*")," multiplication"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"/")," division"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"%")," modulus")),(0,l.kt)("p",null,"Unary plus and unary minus are supported as well:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"LET x = -5\nLET y = 1\nRETURN [-x, +y]\n// [5, 1]\n")),(0,l.kt)("p",null,"For exponentiation, there is a ",(0,l.kt)("a",{parentName:"p",href:"/docs/c8ql/functions/numeric"},"numeric function")," ",(0,l.kt)("inlineCode",{parentName:"p"},"POW()"),". The syntax ",(0,l.kt)("inlineCode",{parentName:"p"},"base ** exp")," is not supported."),(0,l.kt)("p",null,"For string concatenation, you must use the ",(0,l.kt)("a",{parentName:"p",href:"/docs/c8ql/functions/string"},"string function")," ",(0,l.kt)("inlineCode",{parentName:"p"},"CONCAT()"),". Combining two strings with a plus operator (",(0,l.kt)("inlineCode",{parentName:"p"},'"foo" + "bar"'),") will not work!"),(0,l.kt)("p",null,"Some example arithmetic operations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"1 + 1\n33 - 99\n12.4 * 4.5\n13.0 / 0.1\n23 % 7\n-15\n+9.99\n")),(0,l.kt)("p",null,"The arithmetic operators accept operands of any type. Passing non-numeric values to an arithmetic operator will cast the operands to numbers using the type casting rules applied by the ",(0,l.kt)("a",{parentName:"p",href:"/docs/c8ql/functions/type-cast"},"TO_NUMBER()")," function:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"null")," will be converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"0")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"false")," will be converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),", true will be converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"1")),(0,l.kt)("li",{parentName:"ul"},"a valid numeric value remains unchanged, but NaN and Infinity will be converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"0")),(0,l.kt)("li",{parentName:"ul"},"string values are converted to a number if they contain a valid string representation of a number. Any whitespace at the start or the end of the string is ignored. Strings with any other contents are converted to the number ",(0,l.kt)("inlineCode",{parentName:"li"},"0")),(0,l.kt)("li",{parentName:"ul"},"an empty array is converted to ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),", an array with one member is converted to the numeric representation of its sole member. Arrays with more members are converted to the number ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,l.kt)("li",{parentName:"ul"},"objects / documents are converted to the number ",(0,l.kt)("inlineCode",{parentName:"li"},"0"),".")),(0,l.kt)("p",null,"An arithmetic operation that produces an invalid value, such as ",(0,l.kt)("inlineCode",{parentName:"p"},"1 / 0")," (division by zero) will also produce a result value of ",(0,l.kt)("inlineCode",{parentName:"p"},"null"),". The query is not aborted, but you may see a warning."),(0,l.kt)("p",null,"Here are a few examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'1 + "a"                 // 1\n1 + "99"                // 100\n1 + null                // 1\nnull + 1                // 1\n3 + [ ]                 // 3\n24 + [ 2 ]              // 26\n24 + [ 2, 4 ]           // 0\n25 - null               // 25\n17 - true               // 16\n23 * { }                // 0\n5 * [ 7 ]               // 35\n24 / "12"               // 2\n1 / 0                   // 0\n')),(0,l.kt)("h2",{id:"ternary-operator"},"Ternary operator"),(0,l.kt)("p",null,"C8QL also supports a ternary operator that can be used for conditional evaluation. The ternary operator expects a boolean condition as its first operand, and it returns the result of the second operand if the condition evaluates to true, and the third operand otherwise."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"u.age > 15 || u.active == true ? u.userId : null\n")),(0,l.kt)("p",null,"There is also a shortcut variant of the ternary operator with just two operands. This variant can be used when the expression for the boolean condition and the return value should be the same:"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"u.value ? : 'value is null, 0 or not present'\n")),(0,l.kt)("h2",{id:"range-operator"},"Range operator"),(0,l.kt)("p",null,"C8QL supports expressing simple numeric ranges with the ",(0,l.kt)("inlineCode",{parentName:"p"},"..")," operator. This operator can be used to easily iterate over a sequence of numeric values."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"..")," operator will produce an array of the integer values in the defined range, with both bounding values included."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},"2010..2013\n")),(0,l.kt)("p",null,"will produce the following result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},"[ 2010, 2011, 2012, 2013 ]\n")),(0,l.kt)("p",null,"Using the range operator is equivalent to writing an array with the integer values in the range specified by the bounds of the range. If the bounds of the range operator are non-integers, they will be converted to integer values first."),(0,l.kt)("p",null,"There is also a ",(0,l.kt)("a",{parentName:"p",href:"./functions/numeric#range"},"RANGE() function"),"."),(0,l.kt)("h2",{id:"array-operators"},"Array operators"),(0,l.kt)("p",null,"C8QL provides array operators ",(0,l.kt)("inlineCode",{parentName:"p"},"[*]")," for ",(0,l.kt)("a",{parentName:"p",href:"./array-operators#array-expansion"},"array variable expansion")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"[**]")," for ",(0,l.kt)("a",{parentName:"p",href:"./array-operators#array-contraction"},"array contraction"),"."),(0,l.kt)("h2",{id:"operator-precedence"},"Operator precedence"),(0,l.kt)("p",null,"The operator precedence in C8QL is similar as in other familiar languages (lowest precedence first):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"? :")," ternary operator"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"||")," logical or"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"&&")," logical and"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"=="),", ",(0,l.kt)("inlineCode",{parentName:"li"},"!=")," equality and inequality"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"IN")," in operator"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"<"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"<="),", ",(0,l.kt)("inlineCode",{parentName:"li"},">="),", ",(0,l.kt)("inlineCode",{parentName:"li"},">")," less than, less equal, greater equal, greater than"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"+"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"-")," addition, subtraction"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"*"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"/"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"%")," multiplication, division, modulus"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"!"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"+"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"-")," logical negation, unary plus, unary minus"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[*]")," expansion"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"()")," function call"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},".")," member access"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"[]")," indexed value access")),(0,l.kt)("p",null,"The parentheses ",(0,l.kt)("inlineCode",{parentName:"p"},"(")," and ",(0,l.kt)("inlineCode",{parentName:"p"},")")," can be used to enforce a different operator evaluation order."))}m.isMDXComponent=!0}}]);