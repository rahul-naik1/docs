"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4871],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return c}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(t),c=r,g=m["".concat(l,".").concat(c)]||m[c]||d[c]||i;return t?a.createElement(g,o(o({ref:n},p),{},{components:t})):a.createElement(g,o({ref:n},p))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},27222:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return l},default:function(){return c},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d}});var a=t(87462),r=t(63366),i=(t(67294),t(3905)),o=["components"],s={sidebar_position:3,title:"Examples"},l=void 0,u={unversionedId:"c8ql/examples",id:"c8ql/examples",title:"Examples",description:"Overview",source:"@site/docs/c8ql/examples.md",sourceDirName:"c8ql",slug:"/c8ql/examples",permalink:"/docs/c8ql/examples",draft:!1,editUrl:"https://github.com/macrometacorp/docs/edit/master/docs/c8ql/examples.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Examples"},sidebar:"tutorialSidebar",previous:{title:"C8QL Tutorial",permalink:"/docs/c8ql/c8ql-tutorial"},next:{title:"Coming from SQL",permalink:"/docs/c8ql/coming-from-sql"}},p={},d=[{value:"Overview",id:"overview",level:2},{value:"Things to consider",id:"things-to-consider",level:2},{value:"Example data",id:"example-data",level:2},{value:"Counting",id:"counting",level:2},{value:"Data Modifications",id:"data-modifications",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Updating documents",id:"updating-documents",level:3},{value:"Replacing documents",id:"replacing-documents",level:3},{value:"Removing documents",id:"removing-documents",level:3},{value:"Creating documents",id:"creating-documents",level:3},{value:"Copying data from one collection into another",id:"copying-data-from-one-collection-into-another",level:3},{value:"Handling errors",id:"handling-errors",level:3},{value:"Altering substructures",id:"altering-substructures",level:3},{value:"Diffing Two Documents",id:"diffing-two-documents",level:2},{value:"Grouping",id:"grouping",level:2},{value:"Ensuring uniqueness",id:"ensuring-uniqueness",level:3},{value:"Fetching group values",id:"fetching-group-values",level:3},{value:"Variable Expansion",id:"variable-expansion",level:3},{value:"Grouping by multiple criteria",id:"grouping-by-multiple-criteria",level:3},{value:"Counting group values",id:"counting-group-values",level:3},{value:"Aggregation",id:"aggregation",level:3},{value:"Post-aggregation",id:"post-aggregation",level:3},{value:"Post-filtering aggregated data",id:"post-filtering-aggregated-data",level:3},{value:"Joins",id:"joins",level:2},{value:"One-To-Many",id:"one-to-many",level:3},{value:"Many-To-Many",id:"many-to-many",level:3},{value:"Embedded Lists",id:"embedded-lists",level:3},{value:"Using Edge Collections",id:"using-edge-collections",level:3},{value:"Join tuples",id:"join-tuples",level:3},{value:"Horizontal lists",id:"horizontal-lists",level:3},{value:"Self joins",id:"self-joins",level:3},{value:"Outer joins",id:"outer-joins",level:3},{value:"Index usage",id:"index-usage",level:3},{value:"Pitfalls",id:"pitfalls",level:3},{value:"Projections and Filters",id:"projections-and-filters",level:2},{value:"Returning unaltered documents",id:"returning-unaltered-documents",level:3},{value:"Projections",id:"projections",level:3},{value:"Filters",id:"filters",level:3},{value:"Subqueries",id:"subqueries",level:2},{value:"Queries without Collections",id:"queries-without-collections",level:2},{value:"Dynamic Attribute Names",id:"dynamic-attribute-names",level:2},{value:"Using expressions as attribute names",id:"using-expressions-as-attribute-names",level:3},{value:"Subquery solution",id:"subquery-solution",level:3},{value:"Traversals",id:"traversals",level:2},{value:"Finding the start vertex via a geo query",id:"finding-the-start-vertex-via-a-geo-query",level:3},{value:"Multiple Path Search",id:"multiple-path-search",level:2}],m={toc:d};function c(e){var n=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,s,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"These pages contain some common query patterns with examples. For better understandability the query results are also included directly below each query."),(0,i.kt)("p",null,"Normally, you would want to run queries on data stored in collections. This section will provide several examples for that."),(0,i.kt)("p",null,"Some of the following example queries are executed on a collection 'users' with the data provided here below."),(0,i.kt)("h2",{id:"things-to-consider"},"Things to consider"),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"All documents created in any collections will automatically get the following server-generated attributes:"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_id"),": A unique id, consisting of collection name and a server-side sequence value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_key"),": The server sequence value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_rev"),": The document's revision id")),(0,i.kt)("p",null,"Whenever you run queries on the documents in collections, don't be surprised if these additional attributes are returned as well."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"With real-world data, you might want to create additional indexes on the data (left out here for brevity). Adding indexes on attributes that are used in ",(0,i.kt)("inlineCode",{parentName:"li"},"FILTER")," statements may considerably speed up queries."),(0,i.kt)("li",{parentName:"ul"},"Also, instead of using attributes such as ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"from")," and ",(0,i.kt)("em",{parentName:"li"},"to"),", you might want to use the built-in ",(0,i.kt)("inlineCode",{parentName:"li"},"_id"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"_from")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"_to")," attributes."),(0,i.kt)("li",{parentName:"ul"},"Finally, ",(0,i.kt)("inlineCode",{parentName:"li"},"edge collections")," provides a nice way of establishing references / links between documents. These features have been left out here for brevity as well.")))),(0,i.kt)("h2",{id:"example-data"},"Example data"),(0,i.kt)("p",null,"Some of the following example queries are executed on a collection ",(0,i.kt)("inlineCode",{parentName:"p"},"users")," with the following initial data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { "id": 100, "name": "John", "age": 37, "active": true, "gender": "m" },\n  { "id": 101, "name": "Fred", "age": 36, "active": true, "gender": "m" },\n  { "id": 102, "name": "Jacob", "age": 35, "active": false, "gender": "m" },\n  { "id": 103, "name": "Ethan", "age": 34, "active": false, "gender": "m" },\n  { "id": 104, "name": "Michael", "age": 33, "active": true, "gender": "m" },\n  { "id": 105, "name": "Alexander", "age": 32, "active": true, "gender": "m" },\n  { "id": 106, "name": "Daniel", "age": 31, "active": true, "gender": "m" },\n  { "id": 107, "name": "Anthony", "age": 30, "active": true, "gender": "m" },\n  { "id": 108, "name": "Jim", "age": 29, "active": true, "gender": "m" },\n  { "id": 109, "name": "Diego", "age": 28, "active": true, "gender": "m" },\n  { "id": 200, "name": "Sophia", "age": 37, "active": true, "gender": "f" },\n  { "id": 201, "name": "Emma", "age": 36,  "active": true, "gender": "f" },\n  { "id": 202, "name": "Olivia", "age": 35, "active": false, "gender": "f" },\n  { "id": 203, "name": "Madison", "age": 34, "active": true, "gender": "f" },\n  { "id": 204, "name": "Chloe", "age": 33, "active": true, "gender": "f" },\n  { "id": 205, "name": "Eva", "age": 32, "active": false, "gender": "f" },\n  { "id": 206, "name": "Abigail", "age": 31, "active": true, "gender": "f" },\n  { "id": 207, "name": "Isabella", "age": 30, "active": true, "gender": "f" },\n  { "id": 208, "name": "Mary", "age": 29, "active": true, "gender": "f" },\n  { "id": 209, "name": "Mariah", "age": 28, "active": true, "gender": "f" }\n]\n')),(0,i.kt)("p",null,"For some of the examples, we'll also use a collection ",(0,i.kt)("inlineCode",{parentName:"p"},"relations")," to store relationships between users. The example data for ",(0,i.kt)("inlineCode",{parentName:"p"},"relations")," are as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "from": 209, "to": 205, "type": "friend" },\n  { "from": 206, "to": 108, "type": "friend" },\n  { "from": 202, "to": 204, "type": "friend" },\n  { "from": 200, "to": 100, "type": "friend" },\n  { "from": 205, "to": 101, "type": "friend" },\n  { "from": 209, "to": 203, "type": "friend" },\n  { "from": 200, "to": 203, "type": "friend" },\n  { "from": 100, "to": 208, "type": "friend" },\n  { "from": 101, "to": 209, "type": "friend" },\n  { "from": 206, "to": 102, "type": "friend" },\n  { "from": 104, "to": 100, "type": "friend" },\n  { "from": 104, "to": 108, "type": "friend" },\n  { "from": 108, "to": 209, "type": "friend" },\n  { "from": 206, "to": 106, "type": "friend" },\n  { "from": 204, "to": 105, "type": "friend" },\n  { "from": 208, "to": 207, "type": "friend" },\n  { "from": 102, "to": 108, "type": "friend" },\n  { "from": 207, "to": 203, "type": "friend" },\n  { "from": 203, "to": 106, "type": "friend" },\n  { "from": 202, "to": 108, "type": "friend" },\n  { "from": 201, "to": 203, "type": "friend" },\n  { "from": 105, "to": 100, "type": "friend" },\n  { "from": 100, "to": 109, "type": "friend" },\n  { "from": 207, "to": 109, "type": "friend" },\n  { "from": 103, "to": 203, "type": "friend" },\n  { "from": 208, "to": 104, "type": "friend" },\n  { "from": 105, "to": 104, "type": "friend" },\n  { "from": 103, "to": 208, "type": "friend" },\n  { "from": 203, "to": 107, "type": "boyfriend" },\n  { "from": 107, "to": 203, "type": "girlfriend" },\n  { "from": 208, "to": 109, "type": "boyfriend" },\n  { "from": 109, "to": 208, "type": "girlfriend" },\n  { "from": 106, "to": 205, "type": "girlfriend" },\n  { "from": 205, "to": 106, "type": "boyfriend" },\n  { "from": 103, "to": 209, "type": "girlfriend" },\n  { "from": 209, "to": 103, "type": "boyfriend" },\n  { "from": 201, "to": 102, "type": "boyfriend" },\n  { "from": 102, "to": 201, "type": "girlfriend" },\n  { "from": 206, "to": 100, "type": "boyfriend" },\n  { "from": 100, "to": 206, "type": "girlfriend" }\n]\n')),(0,i.kt)("h2",{id:"counting"},"Counting"),(0,i.kt)("p",null,"To return the count of documents that currently exist in a collection, you can call the ",(0,i.kt)("a",{parentName:"p",href:"functions/array#length"},"LENGTH() function"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"    RETURN LENGTH(collection)\n")),(0,i.kt)("p",null,"Internally, ",(0,i.kt)("a",{parentName:"p",href:"functions/miscellaneous#count"},"COLLECTION_COUNT()")," is called."),(0,i.kt)("h2",{id:"data-modifications"},"Data Modifications"),(0,i.kt)("h3",{id:"overview-1"},"Overview"),(0,i.kt)("p",null,"The following operations can be used to modify data of multiple documents with one query. This is superior to fetching and updating the documents individually with multiple queries. However, if only a single document needs to be modified, C8's specialized data-modification operations for single documents might execute faster."),(0,i.kt)("h3",{id:"updating-documents"},"Updating documents"),(0,i.kt)("p",null,"To update existing documents, we can either use the ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," or the ",(0,i.kt)("inlineCode",{parentName:"p"},"REPLACE")," operation. ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," updates only the specified attributes in the found documents, and ",(0,i.kt)("inlineCode",{parentName:"p"},"REPLACE")," completely replaces the found documents with the specified values."),(0,i.kt)("p",null,"We'll start with an ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," query that rewrites the gender attribute in all documents:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  UPDATE u WITH { gender: TRANSLATE(u.gender, { m: 'male', f: 'female' }) } IN users\n")),(0,i.kt)("p",null,"To add new attributes to existing documents, we can also use an ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," query. The following query adds an attribute ",(0,i.kt)("inlineCode",{parentName:"p"},"numberOfLogins")," for all users with status active:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FILTER u.active == true\n  UPDATE u WITH { numberOfLogins: 0 } IN users\n")),(0,i.kt)("p",null,"Existing attributes can also be updated based on their previous value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FILTER u.active == true\n  UPDATE u WITH { numberOfLogins: u.numberOfLogins + 1 } IN users\n")),(0,i.kt)("p",null,"The above query will only work if there was already a ",(0,i.kt)("inlineCode",{parentName:"p"},"numberOfLogins")," attribute present in the document. If it is unsure whether there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"numberOfLogins")," attribute in the document, the increase must be made conditional:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FILTER u.active == true\n  UPDATE u WITH {\n    numberOfLogins: HAS(u, 'numberOfLogins') ? u.numberOfLogins + 1 : 1\n  } IN users\n")),(0,i.kt)("p",null,"Updates of multiple attributes can be combined in a single query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FILTER u.active == true\n  UPDATE u WITH {\n    lastLogin: DATE_NOW(),\n    numberOfLogins: HAS(u, 'numberOfLogins') ? u.numberOfLogins + 1 : 1\n  } IN users\n")),(0,i.kt)("p",null,"Note than an update query might fail during execution, for example because a document to be updated does not exist. In this case, the query will abort at the first error. In single-server mode, all modifications done by the query will be rolled back as if they never happened."),(0,i.kt)("h3",{id:"replacing-documents"},"Replacing documents"),(0,i.kt)("p",null,"To not just partially update, but completely replace existing documents, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"REPLACE")," operation. The following query replaces all documents in the collection backup with the documents found in collection users. Documents common to both collections will be replaced. All other documents will remain unchanged. Documents are compared using their ",(0,i.kt)("inlineCode",{parentName:"p"},"_key")," attributes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  REPLACE u IN backup\n")),(0,i.kt)("p",null,"The above query will fail if there are documents in collection users that are not in collection backup yet. In this case, the query would attempt to replace documents that do not exist. If such case is detected while executing the query, the query will abort. In single-server mode, all changes made by the query will also be rolled back."),(0,i.kt)("p",null,"To make the query succeed for such case, use the ",(0,i.kt)("em",{parentName:"p"},"ignoreErrors")," query option:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  REPLACE u IN backup OPTIONS { ignoreErrors: true }\n")),(0,i.kt)("h3",{id:"removing-documents"},"Removing documents"),(0,i.kt)("p",null,"Deleting documents can be achieved with the ",(0,i.kt)("em",{parentName:"p"},"REMOVE")," operation. To remove all users within a certain age range, we can use the following query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FILTER u.active == true && u.age >= 35 && u.age <= 37\n  REMOVE u IN users\n")),(0,i.kt)("h3",{id:"creating-documents"},"Creating documents"),(0,i.kt)("p",null,"To create new documents, there is the ",(0,i.kt)("em",{parentName:"p"},"INSERT")," operation. It can also be used to generate copies of existing documents from other collections, or to create synthetic documents (e.g. for testing purposes). The following query creates 1000 test users in collection users with some attributes set:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR i IN 1..1000\n  INSERT {\n    id: 100000 + i,\n    age: 18 + FLOOR(RAND() * 25),\n    name: CONCAT('test', TO_STRING(i)),\n    active: false,\n    gender: i % 2 == 0 ? 'male' : 'female'\n  } IN users\n")),(0,i.kt)("h3",{id:"copying-data-from-one-collection-into-another"},"Copying data from one collection into another"),(0,i.kt)("p",null,"To copy data from one collection into another, an ",(0,i.kt)("em",{parentName:"p"},"INSERT")," operation can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  INSERT u IN backup\n")),(0,i.kt)("p",null,"This will copy over all documents from collection users into collection backup. Note that both collections must already exist when the query is executed. The query might fail if backup already contains documents, as executing the insert might attempt to insert the same document (identified by ",(0,i.kt)("inlineCode",{parentName:"p"},"_key")," attribute) again. This will trigger a unique key constraint violation and abort the query. In single-server mode, all changes made by the query will also be rolled back."),(0,i.kt)("p",null,"To make such copy operation work in all cases, the target collection can be emptied before, using a ",(0,i.kt)("inlineCode",{parentName:"p"},"REMOVE")," query."),(0,i.kt)("h3",{id:"handling-errors"},"Handling errors"),(0,i.kt)("p",null,'In some cases it might be desirable to continue execution of a query even in the face of errors (e.g. "document not found"). To continue execution of a query in case of errors, there is the ',(0,i.kt)("em",{parentName:"p"},"ignoreErrors")," option."),(0,i.kt)("p",null,"To use it, place an ",(0,i.kt)("inlineCode",{parentName:"p"},"OPTIONS")," keyword directly after the data modification part of the query, e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  REPLACE u IN backup OPTIONS { ignoreErrors: true }\n")),(0,i.kt)("p",null,"This will continue execution of the query even if errors occur during the ",(0,i.kt)("inlineCode",{parentName:"p"},"REPLACE")," operation. It works similar for ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"REMOVE"),"."),(0,i.kt)("h3",{id:"altering-substructures"},"Altering substructures"),(0,i.kt)("p",null,"To modify lists in documents we have to work with temporary variables. We will collect the sublist in there and alter it. We choose a simple boolean filter condition to make the query better comprehensible."),(0,i.kt)("p",null,"First lets create a collection with a sample:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'database = db._create(\'complexCollection\')\ndatabase.save({\n  "topLevelAttribute" : "a",\n  "subList" : [\n    {\n      "attributeToAlter" : "oldValue",\n      "filterByMe" : true\n    },\n    {\n      "attributeToAlter" : "moreOldValues",\n      "filterByMe" : true\n    },\n    {\n      "attributeToAlter" : "unchangedValue",\n      "filterByMe" : false\n    }\n  ]\n})\n')),(0,i.kt)("p",null,"Heres the Query which keeps the ",(0,i.kt)("inlineCode",{parentName:"p"},"subList")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"alteredList")," to update it later:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR document in complexCollection\n  LET alteredList = (\n    FOR element IN document.subList\n       LET newItem = (! element.filterByMe ?\n                      element :\n                      MERGE(element, { attributeToAlter: "shiny New Value" }))\n       RETURN newItem)\n  UPDATE document WITH { subList:  alteredList } IN complexCollection\n')),(0,i.kt)("p",null,"While the query as it is is now functional:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'db.complexCollection.toArray()\n[\n  {\n    "_id" : "complexCollection/392671569467",\n    "_key" : "392671569467",\n    "_rev" : "392799430203",\n    "topLevelAttribute" : "a",\n    "subList" : [\n      {\n        "filterByMe" : true,\n        "attributeToAlter" : "shiny New Value"\n      },\n      {\n        "filterByMe" : true,\n        "attributeToAlter" : "shiny New Value"\n      },\n      {\n        "filterByMe" : false,\n        "attributeToAlter" : "unchangedValue"\n      }\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"It will probably be soonish a performance bottleneck, since it ",(0,i.kt)("strong",{parentName:"p"},"modifies")," all documents in the collection ",(0,i.kt)("strong",{parentName:"p"},"regardless whether the values change or not"),". Therefore we want to only ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," the documents if we really change their value. Hence we employ a second ",(0,i.kt)("inlineCode",{parentName:"p"},"FOR")," to test whether ",(0,i.kt)("inlineCode",{parentName:"p"},"subList")," will be altered or not:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR document in complexCollection\n  LET willUpdateDocument = (\n    FOR element IN docToAlter.subList\n      FILTER element.filterByMe LIMIT 1 RETURN 1)\n\n  FILTER LENGTH(willUpdateDocument) > 0\n\n  LET alteredList = (\n    FOR element IN document.subList\n       LET newItem = (! element.filterByMe ?\n                      element :\n                      MERGE(element, { attributeToAlter: "shiny New Value" }))\n       RETURN newItem)\n\n  UPDATE document WITH { subList:  alteredList } IN complexCollection\n')),(0,i.kt)("h2",{id:"diffing-two-documents"},"Diffing Two Documents"),(0,i.kt)("p",null,"There is no built-in C8QL function to compare the attributes of two documents, but it is easily possible to build a query that does:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// input document 1\nLET doc1 = {\n  "foo": "bar",\n  "a": 1,\n  "b": 2\n}\n\n// input document 2\nLET doc2 = {\n  "foo": "baz",\n  "a": 2,\n  "c": 3\n}\n\n// collect attributes present in doc1, but missing in doc2\nLET missing = (\n  FOR key IN ATTRIBUTES(doc1)\n  FILTER ! HAS(doc2, key)\n  RETURN {\n    [ key ]: doc1[key]\n  }\n)\n\n// collect attributes present in both docs, but that have different values\nLET changed = (\n  FOR key IN ATTRIBUTES(doc1)\n    FILTER HAS(doc2, key) && doc1[key] != doc2[key]\n    RETURN {\n      [ key ] : {\n        old: doc1[key],\n        new: doc2[key]\n      }\n    }\n)\n\n// collect attributes present in doc2, but missing in doc1\nLET added = (\n  FOR key IN ATTRIBUTES(doc2)\n    FILTER ! HAS(doc1, key)\n    RETURN {\n      [ key ]: doc2[key]\n    }\n)\n\n// return final result\nRETURN {\n  "missing": missing,\n  "changed": changed,\n  "added": added\n}\n')),(0,i.kt)("p",null,"The query may look a bit lengthy, but much of that is due to formatting. A more terse version can be found below."),(0,i.kt)("p",null,"The above query will return a document with three attributes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"missing"),":\nContains all attributes only present in first document\n(i.e. missing in second document)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"changed"),":\nContains all attributes present in both documents that have different values")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"added"),":\nContains all attributes only present in second document\n(i.e. missing in first document)"))),(0,i.kt)("p",null,"For the two example documents it will return:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n {\n   "missing" : [\n     {\n       "b" : 2\n     }\n   ],\n   "changed" : [\n     {\n       "foo" : {\n         "old" : "bar",\n         "new" : "baz"\n       }\n      },\n     {\n       "a" : {\n         "old" : 1,\n         "new" : 2\n       }\n     }\n   ],\n   "added" : [\n     {\n       "c" : 3\n     }\n   ]\n }\n]\n')),(0,i.kt)("p",null,"You may adjust the query to produce a different output format."),(0,i.kt)("p",null,"Following is a version of the same query that can be invoked from JavaScript easily. It passes the two documents as bind parameters and calls ",(0,i.kt)("inlineCode",{parentName:"p"},"db._query"),"."),(0,i.kt)("p",null,"The query is now an one-liner (less readable but easier to copy & paste):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'bindVariables = {\n  doc1 : { "foo" : "bar", "a" : 1, "b" : 2 },\n  doc2 : { "foo" : "baz", "a" : 2, "c" : 3 }\n};\n\nquery = "LET doc1 = @doc1, doc2 = @doc2, missing = (FOR key IN ATTRIBUTES(doc1) FILTER ! HAS(doc2, key) RETURN { [ key ]: doc1[key] }), changed = (FOR key IN ATTRIBUTES(doc1) FILTER HAS(doc2, key) && doc1[key] != doc2[key] RETURN { [ key ] : { old: doc1[key], new: doc2[key] } }), added = (FOR key IN ATTRIBUTES(doc2) FILTER ! HAS(doc1, key) RETURN { [ key ] : doc2[key] }) RETURN { missing : missing, changed : changed, added : added }";\n\nresult = db._query(query, bindVariables).toArray();\n')),(0,i.kt)("h2",{id:"grouping"},"Grouping"),(0,i.kt)("p",null,"To group results by arbitrary criteria, C8QL provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," keyword. ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," will perform a grouping, but no aggregation. Aggregation can still be added in the query if required."),(0,i.kt)("h3",{id:"ensuring-uniqueness"},"Ensuring uniqueness"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," can be used to make a result set unique. The following query will return each distinct ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," attribute value only once:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    COLLECT age = u.age\n    RETURN age\n")),(0,i.kt)("p",null,"This is grouping without tracking the group values, but just the group criterion (",(0,i.kt)("em",{parentName:"p"},"age"),") value."),(0,i.kt)("p",null,"Grouping can also be done on multiple levels using ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    COLLECT status = u.status, age = u.age\n    RETURN { status, age }\n")),(0,i.kt)("p",null,"Alternatively ",(0,i.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT")," can be used to make a result set unique. ",(0,i.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT")," supports a single criterion only:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    RETURN DISTINCT u.age\n")),(0,i.kt)("p",null,"Note: the order of results is undefined for ",(0,i.kt)("inlineCode",{parentName:"p"},"RETURN DISTINCT"),"."),(0,i.kt)("h3",{id:"fetching-group-values"},"Fetching group values"),(0,i.kt)("p",null,"To group users by age, and return the names of the users with the highest ages, we'll issue a query like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT age = u.age INTO usersByAge\n    SORT age DESC LIMIT 0, 5\n    RETURN {\n        age,\n        users: usersByAge[*].u.name\n    }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "age": 37, "users": [ "John", "Sophia" ] },\n  { "age": 36, "users": [ "Fred", "Emma" ] },\n  { "age": 34, "users": [ "Madison" ] },\n  { "age": 33, "users": [ "Chloe", "Michael" ] },\n  { "age": 32, "users": [ "Alexander" ] }\n]\n')),(0,i.kt)("p",null,"The query will put all users together by their ",(0,i.kt)("em",{parentName:"p"},"age")," attribute. There will be one result document per distinct ",(0,i.kt)("em",{parentName:"p"},"age")," value (let aside the ",(0,i.kt)("inlineCode",{parentName:"p"},"LIMIT"),"). For each group, we have access to the matching document via the ",(0,i.kt)("inlineCode",{parentName:"p"},"usersByAge")," variable introduced in the ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement."),(0,i.kt)("h3",{id:"variable-expansion"},"Variable Expansion"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"usersByAge")," variable contains the full documents found, and as we're only interested in user names, we'll use the expansion operator ",(0,i.kt)("i",null,"[*]")," to extract just the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," attribute of all user documents in each group:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"usersByAge[*].u.name\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("i",null,"[*]")," expansion operator is just a handy short-cut. We could also write\na subquery:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"( FOR temp IN usersByAge RETURN temp.u.name )\n")),(0,i.kt)("h3",{id:"grouping-by-multiple-criteria"},"Grouping by multiple criteria"),(0,i.kt)("p",null,"To group by multiple criteria, we'll use multiple arguments in the ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," clause. For example, to group users by ",(0,i.kt)("inlineCode",{parentName:"p"},"ageGroup")," (a derived value we need to calculate first) and then by ",(0,i.kt)("inlineCode",{parentName:"p"},"gender"),", we'll do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender INTO group\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender\n    }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "ageGroup": 35, "gender": "f" },\n  { "ageGroup": 35, "gender": "m" },\n  { "ageGroup": 30, "gender": "f" },\n  { "ageGroup": 30, "gender": "m" },\n  { "ageGroup": 25, "gender": "f" },\n  { "ageGroup": 25, "gender": "m" }\n]\n')),(0,i.kt)("h3",{id:"counting-group-values"},"Counting group values"),(0,i.kt)("p",null,"If the goal is to count the number of values in each group, C8QL provides the special ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT WITH COUNT INTO")," syntax. This is a simple variant for grouping with an additional group length calculation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender WITH COUNT INTO numUsers\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender,\n        numUsers\n    }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  { "ageGroup": 35, "gender": "f", "numUsers": 2 },\n  { "ageGroup": 35, "gender": "m", "numUsers": 2 },\n  { "ageGroup": 30, "gender": "f", "numUsers": 4 },\n  { "ageGroup": 30, "gender": "m", "numUsers": 4 },\n  { "ageGroup": 25, "gender": "f", "numUsers": 2 },\n  { "ageGroup": 25, "gender": "m", "numUsers": 2 }\n]\n')),(0,i.kt)("h3",{id:"aggregation"},"Aggregation"),(0,i.kt)("p",null,"Adding further aggregation is also simple in C8QL by using an ",(0,i.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," clause in the ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender\n    AGGREGATE numUsers = LENGTH(1),\n              minAge = MIN(u.age),\n              maxAge = MAX(u.age)\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender,\n        numUsers,\n        minAge,\n        maxAge\n    }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "ageGroup": 35,\n    "gender": "f",\n    "numUsers": 2,\n    "minAge": 36,\n    "maxAge": 39,\n  },\n  {\n    "ageGroup": 35,\n    "gender": "m",\n    "numUsers": 2,\n    "minAge": 35,\n    "maxAge": 39,\n  },\n  ...\n]\n')),(0,i.kt)("p",null,"We have used the aggregate functions ",(0,i.kt)("inlineCode",{parentName:"p"},"LENGTH")," here (it returns the length of an array). This is the equivalent to SQL's ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT g, COUNT(*) FROM ... GROUP BY g"),". In addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"LENGTH")," C8QL also provides ",(0,i.kt)("inlineCode",{parentName:"p"},"MAX"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"MIN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SUM")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AVERAGE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"VARIANCE_POPULATION"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"VARIANCE_SAMPLE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"STDDEV_POPULATION")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"STDDEV_SAMPLE")," as basic aggregation functions."),(0,i.kt)("p",null,"In C8QL all aggregation functions can be run on arrays only. If an aggregation function is run on anything that is not an array, a warning will be produced and the result will be ",(0,i.kt)("em",{parentName:"p"},"null"),"."),(0,i.kt)("p",null,"Using an ",(0,i.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," clause will ensure the aggregation is run while the groups are built in the collect operation. This is normally more efficient than collecting all group values for all groups and then doing a post-aggregation."),(0,i.kt)("h3",{id:"post-aggregation"},"Post-aggregation"),(0,i.kt)("p",null,"Aggregation can also be performed after a ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," operation using other C8QL constructs, though performance-wise this is often inferior to using ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"AGGREGATE"),"."),(0,i.kt)("p",null,"The same query as before can be turned into a post-aggregation query as shown below. Note that this query will build and pass on all group values for all groups inside the variable ",(0,i.kt)("em",{parentName:"p"},"g"),", and perform the aggregation at the latest possible stage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5,\n            gender = u.gender INTO g\n    SORT ageGroup DESC\n    RETURN {\n        ageGroup,\n        gender,\n        numUsers: LENGTH(g[*]),\n        minAge: MIN(g[*].u.age),\n        maxAge: MAX(g[*].u.age)\n    }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "ageGroup": 35,\n    "gender": "f",\n    "numUsers": 2,\n    "minAge": 36,\n    "maxAge": 39,\n  },\n  {\n    "ageGroup": 35,\n    "gender": "m",\n    "numUsers": 2,\n    "minAge": 35,\n    "maxAge": 39,\n  },\n  ...\n]\n')),(0,i.kt)("p",null,"This is in constrast to the previous query that used an ",(0,i.kt)("inlineCode",{parentName:"p"},"AGGREGATE")," clause to perform the aggregation during the collect operation, at the earliest possible stage."),(0,i.kt)("h3",{id:"post-filtering-aggregated-data"},"Post-filtering aggregated data"),(0,i.kt)("p",null,"To filter the results of a grouping or aggregation operation (i.e. something similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"HAVING")," in SQL), simply add another ",(0,i.kt)("inlineCode",{parentName:"p"},"FILTER")," clause after the ",(0,i.kt)("inlineCode",{parentName:"p"},"COLLECT")," statement."),(0,i.kt)("p",null,"For example, to get the 3 ",(0,i.kt)("inlineCode",{parentName:"p"},"ageGroup"),"s with the most users in them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n    FILTER u.active == true\n    COLLECT ageGroup = FLOOR(u.age / 5) * 5 INTO group\n    LET numUsers = LENGTH(group)\n    FILTER numUsers > 2 /* group must contain at least 3 users in order to qualify */\n    SORT numUsers DESC\n    LIMIT 0, 3\n    RETURN {\n        "ageGroup": ageGroup,\n        "numUsers": numUsers,\n        "users": group[*].u.name\n    }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "ageGroup": 30,\n    "numUsers": 8,\n    "users": [\n      "Abigail",\n      "Madison",\n      "Anthony",\n      "Alexander",\n      "Isabella",\n      "Chloe",\n      "Daniel",\n      "Michael"\n    ]\n  },\n  {\n    "ageGroup": 25,\n    "numUsers": 4,\n    "users": [\n      "Mary",\n      "Mariah",\n      "Jim",\n      "Diego"\n    ]\n  },\n  {\n    "ageGroup": 35,\n    "numUsers": 4,\n    "users": [\n      "Fred",\n      "John",\n      "Emma",\n      "Sophia"\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"To increase readability, the repeated expression ",(0,i.kt)("inlineCode",{parentName:"p"},"LENGTH(group)")," was put into a variable ",(0,i.kt)("inlineCode",{parentName:"p"},"numUsers"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"FILTER")," on ",(0,i.kt)("inlineCode",{parentName:"p"},"numUsers")," is the equivalent an SQL ",(0,i.kt)("inlineCode",{parentName:"p"},"HAVING")," clause."),(0,i.kt)("h2",{id:"joins"},"Joins"),(0,i.kt)("p",null,"The two common scenarios when you want to join documents of collections are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"One-to-Many"),": You may have a collection ",(0,i.kt)("em",{parentName:"p"},"users")," and a collection ",(0,i.kt)("em",{parentName:"p"},"cities"),". A user lives in a city and you need the city information during a query about the user.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Many-To-Many"),": You may have a collection ",(0,i.kt)("em",{parentName:"p"},"authors")," and ",(0,i.kt)("em",{parentName:"p"},"books"),". An author can write many books and a book can have many authors. You want to return a list of books with their authors. Therefore you need to join the authors and books."))),(0,i.kt)("p",null,"Unlike many NoSQL databases, GDN does support joins in C8QL queries. This is similar to the way traditional relational databases handle this. However, because documents allow for more flexibility, joins are also more flexible. The following sections provide solutions for common questions."),(0,i.kt)("p",null,"So far we have only dealt with one collection (",(0,i.kt)("em",{parentName:"p"},"users"),") at a time. We also have a collection ",(0,i.kt)("em",{parentName:"p"},"relations")," that stores relationships between users. We will now use this extra collection to create a result from two collections."),(0,i.kt)("p",null,"First of all, we'll query a few users together with their friends' ids. For that, we'll use all ",(0,i.kt)("em",{parentName:"p"},"relations")," that have a value of ",(0,i.kt)("em",{parentName:"p"},"friend")," in their ",(0,i.kt)("em",{parentName:"p"},"type")," attribute. Relationships are established by using the ",(0,i.kt)("em",{parentName:"p"},"friendOf")," and ",(0,i.kt)("em",{parentName:"p"},"thisUser")," attributes in the ",(0,i.kt)("em",{parentName:"p"},"relations")," collection, which point to the ",(0,i.kt)("em",{parentName:"p"},"userId")," values in the ",(0,i.kt)("em",{parentName:"p"},"users")," collection."),(0,i.kt)("h3",{id:"one-to-many"},"One-To-Many"),(0,i.kt)("p",null,"You have a collection called ",(0,i.kt)("inlineCode",{parentName:"p"},"users"),". Users live in city and a city is identified by its primary key. In principle you can embedded the city document into the users document and be happy with it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "_id" : "users/2151975421",\n  "_key" : "2151975421",\n  "_rev" : "2151975421",\n  "name" : {\n    "first" : "John",\n    "last" : "Doe"\n  },\n  "city" : {\n    "name" : "Metropolis"\n  }\n}\n')),(0,i.kt)("p",null,"This works well for many use cases. Now assume, that you have additional information about the city, like the number of people living in it. It would be impractical to change each and every user document if this numbers changes. Therefore it is good idea to hold the city information in a separate collection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'cities.document("cities/2241300989");\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "population" : 1000, \n  "name" : "Metropolis", \n  "_id" : "cities/2241300989", \n  "_rev" : "2241300989", \n  "_key" : "2241300989" \n}\n')),(0,i.kt)("p",null,"Now you instead of embedding the city directly in the user document, you can use the key of the city."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'users.document("users/2290649597");\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "name" : { \n    "first" : "John", \n    "last" : "Doe" \n  }, \n  "city" : "cities/2241300989", \n  "_id" : "users/2290649597", \n  "_rev" : "2290649597", \n  "_key" : "2290649597" \n}\n')),(0,i.kt)("p",null,"We can now join these two collections very easily."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FOR c IN cities\n    FILTER u.city == c._id RETURN { user: u, city: c }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "user" : { \n      "name" : { \n        "first" : "John", \n        "last" : "Doe" \n      }, \n      "city" : "cities/2241300989", \n      "_id" : "users/2290649597", \n      "_rev" : "2290649597", \n      "_key" : "2290649597" \n    }, \n    "city" : { \n      "population" : 1000, \n      "name" : "Metropolis", \n      "_id" : "cities/2241300989", \n      "_rev" : "2241300989", \n      "_key" : "2241300989" \n    } \n  } \n]\n')),(0,i.kt)("p",null,"Unlike SQL there is no special ",(0,i.kt)("inlineCode",{parentName:"p"},"JOIN")," keyword. The optimizer ensures that the primary index is used in the above query."),(0,i.kt)("p",null,"However, very often it is much more convenient for the client of the query if a single document would be returned, where the city information is embedded in the user document - as in the simple example above. With C8QL there you do not need to forgo this simplification."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users\n  FOR c IN cities\n    FILTER u.city == c._id RETURN merge(u, {city: c})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "users/2290649597", \n    "_key" : "2290649597", \n    "_rev" : "2290649597", \n    "name" : { \n      "first" : "John", \n      "last" : "Doe" \n    }, \n    "city" : { \n      "_id" : "cities/2241300989", \n      "_key" : "2241300989", \n      "_rev" : "2241300989", \n      "population" : 1000, \n      "name" : "Metropolis" \n    } \n  } \n]\n')),(0,i.kt)("p",null,"So you can have both: the convenient representation of the result for your client and the flexibility of joins for your data model."),(0,i.kt)("h3",{id:"many-to-many"},"Many-To-Many"),(0,i.kt)("p",null,"In the relational word you need a third table to model the many-to-many relation. In GDN you have a choice depending on the information you are going to store and the type of questions you are going to ask."),(0,i.kt)("p",null,'Assume that authors are stored in one collection and books in a second. If all you need is "which are the authors of a book" then you can easily model this as a list attribute in users.'),(0,i.kt)("p",null,'If you want to store more information, for example which author wrote which page in a conference proceeding, or if you also want to know "which books were written by which author", you can use edge collections. This is very similar to the "join table" from the relational world.'),(0,i.kt)("h3",{id:"embedded-lists"},"Embedded Lists"),(0,i.kt)("p",null,"If you only want to store the authors of a book, you can embed them as list in the book document. There is no need for a separate collection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"authors.toArray()\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "authors/2661190141", \n    "_key" : "2661190141", \n    "_rev" : "2661190141", \n    "name" : { \n      "first" : "Maxima", \n      "last" : "Musterfrau" \n    } \n  }, \n  { \n    "_id" : "authors/2658437629", \n    "_key" : "2658437629", \n    "_rev" : "2658437629", \n    "name" : { \n      "first" : "John", \n      "last" : "Doe" \n    } \n  } \n]\n')),(0,i.kt)("p",null,"You can query books"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'"FOR b IN books RETURN b"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "books/2681506301", \n    "_key" : "2681506301", \n    "_rev" : "2681506301", \n    "title" : "The beauty of JOINS", \n    "authors" : [ \n      "authors/2661190141", \n      "authors/2658437629" \n    ] \n  } \n]\n')),(0,i.kt)("p",null,"and join the authors in a very similar manner given in the one-to-many section."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\n  LET a = (FOR x IN b.authors \n    FOR a IN authors FILTER x == a._id RETURN a)\n  RETURN { book: b, authors: a }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "book" : { \n      "title" : "The beauty of JOINS", \n      "authors" : [ \n        "authors/2661190141", \n        "authors/2658437629" \n      ], \n      "_id" : "books/2681506301", \n      "_rev" : "2681506301", \n      "_key" : "2681506301" \n    }, \n    "authors" : [ \n      { \n        "name" : { \n          "first" : "Maxima", \n          "last" : "Musterfrau" \n        }, \n        "_id" : "authors/2661190141", \n        "_rev" : "2661190141", \n        "_key" : "2661190141" \n      }, \n      { \n        "name" : { \n          "first" : "John", \n          "last" : "Doe" \n        }, \n        "_id" : "authors/2658437629", \n        "_rev" : "2658437629", \n        "_key" : "2658437629" \n      } \n    ] \n  } \n]\n')),(0,i.kt)("p",null,"\u2026 or embed the authors directly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books LET a = (\n  FOR x IN b.authors \n    FOR a IN authors FILTER x == a._id RETURN a)\n  RETURN merge(b, { authors: a })\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "books/2681506301", \n    "_key" : "2681506301", \n    "_rev" : "2681506301", \n    "title" : "The beauty of JOINS", \n    "authors" : [ \n      { \n        "_id" : "authors/2661190141", \n        "_key" : "2661190141", \n        "_rev" : "2661190141", \n        "name" : { \n          "first" : "Maxima", \n          "last" : "Musterfrau" \n        } \n      }, \n      { \n        "_id" : "authors/2658437629", \n        "_key" : "2658437629", \n        "_rev" : "2658437629", \n        "name" : { \n          "first" : "John", \n          "last" : "Doe" \n        } \n      } \n    ] \n  } \n]\n')),(0,i.kt)("h3",{id:"using-edge-collections"},"Using Edge Collections"),(0,i.kt)("p",null,"If you also want to query which books are written by a given author, embedding authors in the book document is possible, but it is more efficient to use a edge collections for speed."),(0,i.kt)("p",null,"Or you are publishing a proceeding, then you want to store the pages the author has written as well. This information can be stored in the edge document."),(0,i.kt)("p",null,"First create the users"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'db.create("authors");\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'[Collection 2926807549, "authors" (type document, status loaded)]\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'authors.save({ name: { first: "John", last: "Doe" } })\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "authors/2935261693", \n  "_rev" : "2935261693", \n  "_key" : "2935261693" \n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'authors.save({ name: { first: "Maxima", last: "Musterfrau" } })\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "authors/2938210813", \n  "_rev" : "2938210813", \n  "_key" : "2938210813" \n}\n')),(0,i.kt)("p",null,"Now create the books without any author information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'db.create("books");\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[Collection 2928380413, "books" (type document, status loaded)]\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'books.save({ title: "The beauty of JOINS" });\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "books/2980088317", \n  "_rev" : "2980088317", \n  "_key" : "2980088317" \n}\n')),(0,i.kt)("p",null,"An edge collection is now used to link authors and books."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'db.createEdgeCollection("written");\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[Collection 2931132925, "written" (type edge, status loaded)]\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'written.save("authors/2935261693", "books/2980088317", { pages: "1-10" })\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "written/3006237181", \n  "_rev" : "3006237181", \n  "_key" : "3006237181" \n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'written.save("authors/2938210813", "books/2980088317", { pages: "11-20" })\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ \n  "error" : false, \n  "_id" : "written/3012856317", \n  "_rev" : "3012856317", \n  "_key" : "3012856317" \n}\n')),(0,i.kt)("p",null,"In order to get all books with their authors you can use a ",(0,i.kt)("a",{parentName:"p",href:"./graphs/traversals#working-with-collection-sets"},"graph traversal")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\nLET authorsByBook = (\n  FOR author, writtenBy IN INBOUND b written\n    RETURN {\n        vertex: author,\n        edge: writtenBy\n    }\n)\nRETURN {\n    book: b,\n    authors: authorsByBook\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "book" : {\n      "_key" : "2980088317",\n      "_id" : "books/2980088317",\n      "_rev" : "2980088317",\n      "title" : "The beauty of JOINS"\n    },\n    "authors" : [\n      {\n        "vertex" : {\n          "_key" : "2935261693",\n          "_id" : "authors/2935261693",\n          "_rev" : "2935261693",\n          "name" : {\n            "first" : "John",\n            "last" : "Doe"\n          }\n        },\n        "edge" : {\n          "_key" : "2935261693",\n          "_id" : "written/2935261693",\n          "_from" : "authors/2935261693",\n          "_to" : "books/2980088317",\n          "_rev" : "3006237181",\n          "pages" : "1-10"\n        }\n      },\n      {\n        "vertex" : {\n          "_key" : "2938210813",\n          "_id" : "authors/2938210813",\n          "_rev" : "2938210813",\n          "name" : {\n            "first" : "Maxima",\n            "last" : "Musterfrau"\n          }\n        },\n        "edge" : {\n          "_key" : "6833274",\n          "_id" : "written/6833274",\n          "_from" : "authors/2938210813",\n          "_to" : "books/2980088317",\n          "_rev" : "3012856317",\n          "pages" : "11-20"\n        }\n      }\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"Or if you want only the information stored in the vertices."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\nLET authorsByBook = (\n    FOR author IN INBOUND b written\n    OPTIONS {\n        bfs: true,\n        uniqueVertices: 'global'\n    }\n    RETURN author\n)\nRETURN {\n    book: b,\n    authors: authorsByBook\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "book" : {\n      "_key" : "2980088317",\n      "_id" : "books/2980088317",\n      "_rev" : "2980088317",\n      "title" : "The beauty of JOINS"\n    },\n    "authors" : [\n      {\n        "_key" : "2938210813",\n        "_id" : "authors/2938210813",\n        "_rev" : "2938210813",\n        "name" : {\n          "first" : "Maxima",\n          "last" : "Musterfrau"\n        }\n      },\n      {\n        "_key" : "2935261693",\n        "_id" : "authors/2935261693",\n        "_rev" : "2935261693",\n        "name" : {\n          "first" : "John",\n          "last" : "Doe"\n        }\n      }\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"Or again embed the authors directly into the book document."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR b IN books\nLET authors = (\n    FOR author IN INBOUND b written\n    OPTIONS {\n        bfs: true,\n        uniqueVertices: 'global'\n    }\n    RETURN author\n)\nRETURN MERGE(b, {authors: authors})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "_id" : "books/2980088317",\n    "_key" : "2980088317",\n    "_rev" : "2980088317",\n    "title" : "The beauty of JOINS",\n    "authors" : [\n      {\n        "_key" : "2938210813",\n        "_id" : "authors/2938210813",\n        "_rev" : "2938210813",\n        "name" : {\n          "first" : "Maxima",\n          "last" : "Musterfrau"\n        }\n      },\n      {\n        "_key" : "2935261693",\n        "_id" : "authors/2935261693",\n        "_rev" : "2935261693",\n        "name" : {\n          "first" : "John",\n          "last" : "Doe"\n        }\n      }\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"If you need the authors and their books, simply reverse the direction."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR a IN authors\nLET booksByAuthor = (\n    FOR b IN OUTBOUND a written\n    OPTIONS {\n        bfs: true,\n        uniqueVertices: 'global'\n    }\n    RETURN b\n)\nRETURN MERGE(a, {books: booksByAuthor})\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "_id" : "authors/2935261693",\n    "_key" : "2935261693",\n    "_rev" : "2935261693",\n    "name" : {\n      "first" : "John",\n      "last" : "Doe"\n    },\n    "books" : [\n      {\n        "_key" : "2980088317",\n        "_id" : "books/2980088317",\n        "_rev" : "2980088317",\n        "title" : "The beauty of JOINS"\n      }\n    ]\n  },\n  {\n    "_id" : "authors/2938210813",\n    "_key" : "2938210813",\n    "_rev" : "2938210813",\n    "name" : {\n      "first" : "Maxima",\n      "last" : "Musterfrau"\n    },\n    "books" : [\n      {\n        "_key" : "2980088317",\n        "_id" : "books/2980088317",\n        "_rev" : "2980088317",\n        "title" : "The beauty of JOINS"\n      }\n    ]\n  }\n]\n')),(0,i.kt)("h3",{id:"join-tuples"},"Join tuples"),(0,i.kt)("p",null,"We will start with a SQL-ish result set and return each tuple (user name, friends userId) separately. The C8QL query to generate such result is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'    FOR u IN users\n      FILTER u.active == true\n      LIMIT 0, 4\n      FOR f IN relations\n        FILTER f.type == @friend && f.friendOf == u.userId\n        RETURN {\n          "user" : u.name,\n          "friendId" : f.thisUser\n        }\n    @BV {\n    friend: "friend"\n    }\n')),(0,i.kt)("p",null,"We iterate over the collection users. Only the 'active' users will be examined. For each of these users we will search for up to 4 friends. We locate friends by comparing the ",(0,i.kt)("em",{parentName:"p"},"userId")," of our current user with the ",(0,i.kt)("em",{parentName:"p"},"friendOf")," attribute of the ",(0,i.kt)("em",{parentName:"p"},"relations")," document. For each of those relations found we return the users name and the userId of the friend."),(0,i.kt)("h3",{id:"horizontal-lists"},"Horizontal lists"),(0,i.kt)("p",null,"Note that in the above result, a user can be returned multiple times. This is the SQL way of returning data. If this is not desired, the friends' ids of each user can be returned in a horizontal list. This will return each user at most once."),(0,i.kt)("p",null,"The C8QL query for doing so is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  FILTER u.active == true LIMIT 0, 4\n  RETURN {\n    "user" : u.name,\n    "friendIds" : (\n      FOR f IN relations\n        FILTER f.friendOf == u.userId && f.type == "friend"\n        RETURN f.thisUser\n    )\n  }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user" : "Abigail",\n    "friendIds" : [\n      108,\n      102,\n      106\n    ]\n  },\n  {\n    "user" : "Fred",\n    "friendIds" : [\n      209\n    ]\n  },\n  {\n    "user" : "Mary",\n    "friendIds" : [\n      207,\n      104\n    ]\n  },\n  {\n    "user" : "Mariah",\n    "friendIds" : [\n      203,\n      205\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"In this query we are still iterating over the users in the ",(0,i.kt)("em",{parentName:"p"},"users")," collection and for each matching user we are executing a subquery to create the matching list of related users."),(0,i.kt)("h3",{id:"self-joins"},"Self joins"),(0,i.kt)("p",null,'To not only return friend ids but also the names of friends, we could "join" the ',(0,i.kt)("em",{parentName:"p"},"users"),' collection once more (something like a "self join"):'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users\n  FILTER u.active == true\n  LIMIT 0, 4\n  RETURN {\n    "user" : u.name,\n    "friendIds" : (\n      FOR f IN relations\n        FILTER f.friendOf == u.userId && f.type == "friend"\n        FOR u2 IN users\n          FILTER f.thisUser == u2.useId\n          RETURN u2.name\n    )\n  }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user" : "Abigail",\n    "friendIds" : [\n      "Jim",\n      "Jacob",\n      "Daniel"\n    ]\n  },\n  {\n    "user" : "Fred",\n    "friendIds" : [\n      "Mariah"\n    ]\n  },\n  {\n    "user" : "Mary",\n    "friendIds" : [\n      "Isabella",\n      "Michael"\n    ]\n  },\n  {\n    "user" : "Mariah",\n    "friendIds" : [\n      "Madison",\n      "Eva"\n    ]\n  }\n]\n')),(0,i.kt)("p",null,"This query will then again in term fetch the clear text name of the friend from the users collection. So here we iterate the users collection, and for each hit the relations collection, and for each hit once more the users collection."),(0,i.kt)("h3",{id:"outer-joins"},"Outer joins"),(0,i.kt)("p",null,"Lets find the lonely people in our database - those without friends."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'\nFOR user IN users\n  LET friendList = (\n    FOR f IN relations\n      FILTER f.friendOf == u.userId\n      RETURN 1\n  )\n  FILTER LENGTH(friendList) == 0\n  RETURN { "user" : user.name }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user" : "Abigail"\n  },\n  {\n    "user" : "Fred"\n  }\n]\n')),(0,i.kt)("p",null,"So, for each user we pick the list of their friends and count them. The ones where count equals zero are the lonely people. Using ",(0,i.kt)("em",{parentName:"p"},"RETURN 1")," in the subquery saves even more precious CPU cycles and gives the optimizer more alternatives."),(0,i.kt)("h3",{id:"index-usage"},"Index usage"),(0,i.kt)("p",null,"Especially on joins you should make sure indices can be used to speed up your query). Please note that sparse indices don't qualify for joins:"),(0,i.kt)("p",null,"In joins you typically would also want to join documents not containing the property you join with. However sparse indices don't contain references to documents that don't contain the indexed attributes - thus they would be missing from the join operation. For that reason you should provide non-sparse indices. "),(0,i.kt)("h3",{id:"pitfalls"},"Pitfalls"),(0,i.kt)("p",null,"Since we're free of schemata, there is by default no way to tell the format of the documents. So, if your documents don't contain an attribute, it defaults to null. We can however check our data for accuracy like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"RETURN LENGTH(FOR u IN users FILTER u.userId == null RETURN 1)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"[\n  10000\n]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"RETURN LENGTH(FOR f IN relations FILTER f.friendOf == null RETURN 1)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"[\n  10000\n]\n")),(0,i.kt)("p",null,"So if the above queries return 10k matches each, the result of the Join tuples query will become 100,000,000 items larger and use much memory plus computation time. So it is generally a good idea to revalidate that the criteria for your join conditions exist."),(0,i.kt)("p",null,"Using indices on the properties can speed up the operation significantly. You can use the explain helper to revalidate your query actually uses them."),(0,i.kt)("p",null,"If you work with joins on edge collections you would typically aggregate over the internal fields ",(0,i.kt)("inlineCode",{parentName:"p"},"_id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"_from")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"_to")," (where ",(0,i.kt)("inlineCode",{parentName:"p"},"_id")," equals ",(0,i.kt)("inlineCode",{parentName:"p"},"userId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"_from")," would be ",(0,i.kt)("inlineCode",{parentName:"p"},"friendOf")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"_to")," would be ",(0,i.kt)("inlineCode",{parentName:"p"},"thisUser")," in our examples). GDN implicitly creates indices on them."),(0,i.kt)("h2",{id:"projections-and-filters"},"Projections and Filters"),(0,i.kt)("h3",{id:"returning-unaltered-documents"},"Returning unaltered documents"),(0,i.kt)("p",null,"To return three complete documents from collection ",(0,i.kt)("inlineCode",{parentName:"p"},"users"),", the following query can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR u IN users \n  LIMIT 0, 3\n  RETURN u\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "_id" : "users/229886047207520", \n    "_rev" : "229886047207520", \n    "_key" : "229886047207520", \n    "active" : true, \n    "id" : 206, \n    "age" : 31, \n    "gender" : "f", \n    "name" : "Abigail" \n  }, \n  { \n    "_id" : "users/229886045175904", \n    "_rev" : "229886045175904", \n    "_key" : "229886045175904", \n    "active" : true, \n    "id" : 101, \n    "age" : 36, \n    "name" : "Fred", \n    "gender" : "m" \n  }, \n  { \n    "_id" : "users/229886047469664", \n    "_rev" : "229886047469664", \n    "_key" : "229886047469664", \n    "active" : true, \n    "id" : 208, \n    "age" : 29, \n    "name" : "Mary", \n    "gender" : "f" \n  }\n]\n')),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"There is a ",(0,i.kt)("inlineCode",{parentName:"p"},"LIMIT")," clause but no ",(0,i.kt)("inlineCode",{parentName:"p"},"SORT")," clause. In this case it is not guaranteed which of the user documents are returned. Effectively the document return order is unspecified if no ",(0,i.kt)("inlineCode",{parentName:"p"},"SORT")," clause is used, and you should not rely on the order in such queries."))),(0,i.kt)("h3",{id:"projections"},"Projections"),(0,i.kt)("p",null,"To return a projection from the collection ",(0,i.kt)("inlineCode",{parentName:"p"},"users")," use a modified ",(0,i.kt)("inlineCode",{parentName:"p"},"RETURN")," instruction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users \n  LIMIT 0, 3\n  RETURN { \n    "user" : { \n      "isActive" : u.active ? "yes" : "no", \n      "name" : u.name \n    } \n  }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "user" : { \n      "isActive" : "yes", \n      "name" : "John" \n    } \n  }, \n  { \n    "user" : { \n      "isActive" : "yes", \n      "name" : "Anthony" \n    } \n  }, \n  { \n    "user" : { \n      "isActive" : "yes", \n      "name" : "Fred" \n    } \n  }\n]\n')),(0,i.kt)("h3",{id:"filters"},"Filters"),(0,i.kt)("p",null,"To return a filtered projection from collection ",(0,i.kt)("inlineCode",{parentName:"p"},"users"),", you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"FILTER")," keyword. Additionally, a ",(0,i.kt)("inlineCode",{parentName:"p"},"SORT")," clause is used to have the result returned in a specific order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR u IN users \n  FILTER u.active == true && u.age >= 30\n  SORT u.age DESC\n  LIMIT 0, 5\n  RETURN { \n    "age" : u.age, \n    "name" : u.name \n  }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[ \n  { \n    "age" : 37, \n      "name" : "Sophia" \n  }, \n  { \n    "age" : 37, \n    "name" : "John" \n  }, \n  { \n    "age" : 36, \n    "name" : "Emma" \n  }, \n  { \n    "age" : 36, \n    "name" : "Fred" \n  }, \n  { \n    "age" : 34, \n    "name" : "Madison" \n  } \n]\n')),(0,i.kt)("h2",{id:"subqueries"},"Subqueries"),(0,i.kt)("p",null,"Wherever an expression is allowed in C8QL, a subquery can be placed. A subquery is a query part that can introduce its own local variables without affecting variables and values in its outer scope(s)."),(0,i.kt)("p",null,"It is required that subqueries be put inside parentheses ",(0,i.kt)("inlineCode",{parentName:"p"},"(")," and ",(0,i.kt)("inlineCode",{parentName:"p"},")")," to explicitly mark their start and end points:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR p IN persons\n  LET recommendations = (\n    FOR r IN recommendations\n      FILTER p.id == r.personId\n      SORT p.rank DESC\n      LIMIT 10\n      RETURN r\n  )\n  RETURN { person : p, recommendations : recommendations }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"FOR p IN persons\n  COLLECT city = p.city INTO g\n  RETURN {\n    city : city,\n    numPersons : LENGTH(g),\n    maxRating: MAX(\n      FOR r IN g\n      RETURN r.p.rating\n    )}\n")),(0,i.kt)("p",null,"Subqueries may also include other subqueries."),(0,i.kt)("p",null,"Note that subqueries always return a result ",(0,i.kt)("strong",{parentName:"p"},"array"),", even if there is only a single return value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"RETURN ( RETURN 1 )\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"[ [ 1 ] ]\n")),(0,i.kt)("p",null,"To avoid such a nested data structure,  ",(0,i.kt)("a",{parentName:"p",href:"./functions/array#first"},"FIRST()")," can be used for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"RETURN FIRST( RETURN 1 )\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"[ 1 ]\n")),(0,i.kt)("h2",{id:"queries-without-collections"},"Queries without Collections"),(0,i.kt)("p",null,"Following is a query that returns a string value. The result string is contained in an array because the result of every valid query is an array:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'RETURN "this will be returned"\n[ \n  "this will be returned" \n]\n')),(0,i.kt)("p",null,"Here is a query that creates the cross products of two arrays and runs a projection on it, using a few of C8QL's built-in functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'FOR year in [ 2011, 2012, 2013 ]\n  FOR quarter IN [ 1, 2, 3, 4 ]\n    RETURN { \n      "y" : "year", \n      "q" : quarter, \n      "nice" : CONCAT(quarter, "/", year) \n    }\n[ \n  { "y" : "year", "q" : 1, "nice" : "1/2011" }, \n  { "y" : "year", "q" : 2, "nice" : "2/2011" }, \n  { "y" : "year", "q" : 3, "nice" : "3/2011" }, \n  { "y" : "year", "q" : 4, "nice" : "4/2011" }, \n  { "y" : "year", "q" : 1, "nice" : "1/2012" }, \n  { "y" : "year", "q" : 2, "nice" : "2/2012" }, \n  { "y" : "year", "q" : 3, "nice" : "3/2012" }, \n  { "y" : "year", "q" : 4, "nice" : "4/2012" }, \n  { "y" : "year", "q" : 1, "nice" : "1/2013" }, \n  { "y" : "year", "q" : 2, "nice" : "2/2013" }, \n  { "y" : "year", "q" : 3, "nice" : "3/2013" }, \n  { "y" : "year", "q" : 4, "nice" : "4/2013" } \n]\n')),(0,i.kt)("h2",{id:"dynamic-attribute-names"},"Dynamic Attribute Names"),(0,i.kt)("p",null,"You might want a C8QL query to return results with attribute names assembled by a function, or with a variable number of attributes."),(0,i.kt)("p",null,"This will not work by specifying the result using a regular object literal, as object literals require the names and numbers of attributes to be fixed at query compile time."),(0,i.kt)("p",null,"There are two solutions to getting dynamic attribute names to work:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Using expressions as attribute names (fixed amount of attributes)"),(0,i.kt)("li",{parentName:"ul"},"Using subqueries and the ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIP()")," function (variable amount of attributes)")),(0,i.kt)("h3",{id:"using-expressions-as-attribute-names"},"Using expressions as attribute names"),(0,i.kt)("p",null,"This solution works in cases where the number of dynamic attributes to return is known in advance, and only the attribute names need to be calculated using an expression."),(0,i.kt)("p",null,"GDN allows using expressions instead of fixed attribute names in object literals. Using expressions as attribute names requires enclosing the expression in extra ",(0,i.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"]")," to disambiguate them from regular, unquoted attribute names."),(0,i.kt)("p",null,"Let us create a result that returns the original document data contained in a dynamically named attribute. We will be using the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"doc.type")," for the attribute name. We will also return some other attributes from the original documents, but prefix them with the documents' ",(0,i.kt)("inlineCode",{parentName:"p"},"_key")," attribute values. For this we also need attribute name expressions."),(0,i.kt)("p",null,"Here is a query showing how to do this. The attribute name expressions all required to be enclosed in ",(0,i.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"]")," in order to make this work:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "_key" : "3231748397810", "gender" : "f", "status" : "active", "type" : "user" },\n  { "_key" : "3231754427122", "gender" : "m", "status" : "inactive", "type" : "unknown" }\n]\n\nFOR doc IN documents\n  RETURN {\n    [ doc.type ] : {\n      [ CONCAT(doc._key, "_gender") ] : doc.gender,\n      [ CONCAT(doc._key, "_status") ] : doc.status\n    }\n  }\n')),(0,i.kt)("p",null,"This will return:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "user": {\n      "3231748397810_gender": "f",\n      "3231748397810_status": "active"\n    }\n  },\n  {\n    "unknown": {\n      "3231754427122_gender": "m",\n      "3231754427122_status": "inactive"\n    }\n  }\n]\n')),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Attribute name expressions and regular, unquoted attribute names can be mixed."))),(0,i.kt)("h3",{id:"subquery-solution"},"Subquery solution"),(0,i.kt)("p",null,"A generalized solution is to let a subquery or another function produce the dynamic attribute names, and finally pass them through the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIP()")," function to create an object from them."),(0,i.kt)("p",null,"Let us assume we want to process the following input documents:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{ "name": "test", "gender": "f", "status": "active", "type": "user" }\n{ "name": "dummy", "gender": "m", "status": "inactive", "type": "unknown", "magicFlag": 23 }\n')),(0,i.kt)("p",null,"Let us also assume our goal for each of these documents is to return only the attribute names that contain the letter ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", together with their respective values."),(0,i.kt)("p",null,"To extract the attribute names and values from the original documents, we can use a subquery as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "name": "test"," gender": "f", "status": "active", "type": "user" },\n  { "name": "dummy", "gender": "m", "status": "inactive", "type": "unknown", "magicFlag": 23 }\n]\n\nFOR doc IN documents\n  RETURN (\n    FOR name IN ATTRIBUTES(doc)\n      FILTER LIKE(name, \'%a%\')\n      RETURN {\n        name: name,\n        value: doc[name]\n      }\n  )\n')),(0,i.kt)("p",null,"The subquery will only let attribute names pass that contain the letter ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". The results of the subquery are then made available to the main query and will be returned. But the attribute names in the result are still ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),", so we're not there yet."),(0,i.kt)("p",null,"So let us also employ C8QL's ",(0,i.kt)("a",{parentName:"p",href:"./functions/document#zip"},"ZIP()")," function, which can create an object from two arrays:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the first parameter to ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIP()")," is an array with the attribute names"),(0,i.kt)("li",{parentName:"ul"},"the second parameter to ",(0,i.kt)("inlineCode",{parentName:"li"},"ZIP()")," is an array with the attribute values")),(0,i.kt)("p",null,"Instead of directly returning the subquery result, we first capture it in a variable, and pass the variable's ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," components into ",(0,i.kt)("inlineCode",{parentName:"p"},"ZIP()")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "name" : "test"," gender" : "f", "status" : "active", "type" : "user" },\n  { "name" : "dummy", "gender" : "m", "status" : "inactive", "type" : "unknown", "magicFlag" : 23 }\n]\n\nFOR doc IN documents\n  LET attributes = (\n    FOR name IN ATTRIBUTES(doc)\n      FILTER LIKE(name, \'%a%\')\n      RETURN {\n        name: name,\n        value: doc[name]\n      }\n  )\n  RETURN ZIP(attributes[*].name, attributes[*].value)\n')),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"We have to use the expansion operator (",(0,i.kt)("inlineCode",{parentName:"p"},"[*]"),") on ",(0,i.kt)("inlineCode",{parentName:"p"},"attributes")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"attributes")," itself is an array, and we want either the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," attribute or the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," attribute of each of its members."))),(0,i.kt)("p",null,"To prove this is working, here is the above query's result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "name": "test",\n    "status": "active"\n  },\n  {\n    "name": "dummy",\n    "status": "inactive",\n    "magicFlag": 23\n  }\n]\n')),(0,i.kt)("p",null,"As can be seen, the two results have a different amount of result attributes. We can also make the result a bit more dynamic by prefixing each attribute with the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," attribute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'LET documents = [\n  { "name": "test"," gender": "f", "status": "active", "type": "user" },\n  { "name": "dummy", "gender": "m", "status": "inactive", "type": "unknown", "magicFlag": 23 }\n]\n\nFOR doc IN documents\n  LET attributes = (\n    FOR name IN ATTRIBUTES(doc)\n      FILTER LIKE(name, \'%a%\')\n      RETURN {\n        name: CONCAT(doc.name, \'-\', name),\n        value: doc[name]\n      }\n  )\n  RETURN ZIP(attributes[*].name, attributes[*].value)\n')),(0,i.kt)("p",null,"That will give us document-specific attribute names like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "test-name": "test",\n    "test-status": "active"\n  },\n  {\n    "dummy-name": "dummy",\n    "dummy-status": "inactive",\n    "dummy-magicFlag": 23\n  }\n]\n')),(0,i.kt)("h2",{id:"traversals"},"Traversals"),(0,i.kt)("h3",{id:"finding-the-start-vertex-via-a-geo-query"},"Finding the start vertex via a geo query"),(0,i.kt)("p",null,"Our first example will locate the start vertex for a graph traversal via ",(0,i.kt)("a",{parentName:"p",href:"../collections/documents/indexing/index-basics#geo-index"},"a geo index"),"."),(0,i.kt)("p",null,"We use the city graph and its geo indices: ",(0,i.kt)("img",{alt:"cities_graph(1)",src:t(62417).Z,width:"992",height:"777"}),'{height="" width=""}'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"var bonn=[50.7340, 7.0998];\n\nFOR startCity IN\n    WITHIN(germanCity, @lat, @long, @radius)\n    RETURN startCity\n\n{lat: bonn[0], long: bonn[1], radius: 400000}\n")),(0,i.kt)("p",null,"We search all german cities in a range of 400 km around the ex-capital ",(0,i.kt)("strong",{parentName:"p"},"Bonn"),": ",(0,i.kt)("strong",{parentName:"p"},"Hamburg")," and ",(0,i.kt)("strong",{parentName:"p"},"Cologne"),". We won't find ",(0,i.kt)("strong",{parentName:"p"},"Paris")," since its in the ",(0,i.kt)("inlineCode",{parentName:"p"},"frenchCity")," collection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"var bonn=[50.7340, 7.0998];\n\nFOR startCity IN\n    WITHIN(germanCity, @lat, @long, @radius)\n        FOR v, e, p IN 1..1 OUTBOUND startCity\n            GRAPH 'routeplanner'\n                RETURN {startcity: startCity._key, traversedCity: v}\n\n{lat: bonn[0], long: bonn[1], radius: 400000}\n")),(0,i.kt)("p",null,"The geo index query returns us ",(0,i.kt)("inlineCode",{parentName:"p"},"startCity")," (",(0,i.kt)("strong",{parentName:"p"},"Cologne")," and ",(0,i.kt)("strong",{parentName:"p"},"Hamburg"),") which we then use as starting point for our graph traversal. For simplicity we only return their direct neighbours. We format the return result so we can see from which ",(0,i.kt)("inlineCode",{parentName:"p"},"startCity")," the traversal came."),(0,i.kt)("p",null,"Alternatively we could use a ",(0,i.kt)("inlineCode",{parentName:"p"},"LET")," statement with a subquery to group the traversals by their ",(0,i.kt)("inlineCode",{parentName:"p"},"startCity")," efficiently:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"var bonn=[50.7340, 7.0998];\n\nFOR startCity IN\n    WITHIN(germanCity, @lat, @long, @radius)\n        LET oneCity = (FOR v, e, p IN 1..1 OUTBOUND startCity\n            GRAPH 'routeplanner' RETURN v)\n                return {startCity: startCity._key, connectedCities: oneCity}\n\n{lat: bonn[0], long: bonn[1], radius: 400000}\n")),(0,i.kt)("h2",{id:"multiple-path-search"},"Multiple Path Search"),(0,i.kt)("p",null,"The shortest path algorithm can only determine one shortest path."),(0,i.kt)("p",null,"For example, if this is the full graph (based on the ",(0,i.kt)("a",{target:"_blank",href:t(23375).Z},"mps_graph"),"):"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Example Graph",src:t(4451).Z,width:"2080",height:"1460"})),(0,i.kt)("p",null,"then a shortest path query from ",(0,i.kt)("strong",{parentName:"p"},"A")," to ",(0,i.kt)("strong",{parentName:"p"},"C")," may return the path ",(0,i.kt)("inlineCode",{parentName:"p"},"A -> B -> C")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"A -> D -> C"),", but it's undefined which one (not taking edge weights into account here)."),(0,i.kt)("p",null,"You can use the efficient shortest path algorithm however, to determine the shortest path length:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'    RETURN LENGTH(\n      FOR v IN OUTBOUND\n        SHORTEST_PATH "mps_verts/A" TO "mps_verts/C" mps_edges\n          RETURN v\n    )   \n')),(0,i.kt)("p",null,"The result is 3 for the example graph (includes the start vertex). Now, subtract 1 to get the edge count / traversal depth. "),(0,i.kt)("p",null,"You can run a pattern matching traversal to find all paths with this length (or longer ones by increasing the min and max depth). Starting point is ",(0,i.kt)("strong",{parentName:"p"},"A")," again, and a filter on the document ID of v (or p.vertices","[-1]",") ensures that we only retrieve paths that end at point ",(0,i.kt)("strong",{parentName:"p"},"C"),"."),(0,i.kt)("p",null,"The following query returns all parts with length 2, start vertex ",(0,i.kt)("strong",{parentName:"p"},"A")," and target vertex ",(0,i.kt)("strong",{parentName:"p"},"C"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'    FOR v, e, p IN 2..2 OUTBOUND "mps_verts/A" mps_edges\n       FILTER v._id == "mps_verts/C"\n         RETURN CONCAT_SEPARATOR(" -> ", p.vertices[*]._key)\n')),(0,i.kt)("p",null,"A traversal depth of ",(0,i.kt)("inlineCode",{parentName:"p"},"3..3")," would return ",(0,i.kt)("inlineCode",{parentName:"p"},"A -> E -> F -> C")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"2..3")," all three paths."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Two separate queries are required to compute the shortest path length and to do the pattern matching based on the shortest path length (minus 1), because min and max depth can't be expressions (they have to be known in advance, so either be number literals or bind parameters."))))}c.isMDXComponent=!0},23375:function(e,n,t){n.Z=t.p+"assets/files/mps_graph-62c72b9517362812b0bc7d7ddadf82d1.png"},62417:function(e,n,t){n.Z=t.p+"assets/images/cities_graph-d8e1073687e912930a91dbfc98bd8fe3.png"},4451:function(e,n,t){n.Z=t.p+"assets/images/mps_graph-62c72b9517362812b0bc7d7ddadf82d1.png"}}]);